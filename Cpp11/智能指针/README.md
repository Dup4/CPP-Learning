# 智能指针

## auto_ptr

- 智能指针可以像类的原始指针一样访问类的 public 成员，成员函数 get() 返回一个原始的指针，成员函数 reset() 重新绑定指向的对象，而原来的对象则会被释放。注意我们访问 auto_ptr 的成员函数时用的是 `.`，访问指向对象的成员时用的是 `->`。我们也可用声明一个空智能指针 `auto_ptr<Test>ptest();`
- 当我们对智能指针进行赋值时，如 `ptest2 = ptest`，`ptest2` 会接管 `ptest` 原来的内存管理权，`ptest` 会变为空指针，如果 `ptest2` 原来不为空，则它会释放原来的资源，基于这个原因，应该避免把 `auto_ptr` 放到容器中，因为算法对容器操作时，很难避免STL内部对容器实现了赋值传递操作，这样会使容器中很多元素被置为NULL。
- 判断一个智能指针是否为空不能使用 `if(ptest == NULL)`，应该使用 `if(ptest.get() == NULL)`。

## unique_ptr

- unique_ptr 是一个独享所有权的智能指针，它提供了严格意义上的所有权，包括：
  - 拥有它指向的对象
  - 无法进行复制构造，无法进行复制赋值操作。即无法使两个 unique_ptr 指向同一个对象。但是可以进行移动构造和移动赋值操作。
  - 保存指向某个对象的指针，当它本身被删除释放的时候，会使用给定的删除器释放它指向的对象
- unique_ptr 可以实现如下功能：
    - 为动态申请的内存提供异常安全
    - 讲动态申请的内存所有权传递给某函数
    - 从某个函数返回动态申请内存的所有权
    - 在容器中保存指针
  
## share_ptr

- 从名字 share 就可以看出了资源可以被多个指针共享。
- 它使用计数机制来表明资源被几个指针共享。
- 可以通过成员函数 `use_count()` 来查看资源的所有者个数。除了可以通过 `new` 来构造，还可以通过传入 auto_ptr, unique_ptr, weak_ptr 来构造。当我们调用 release() 时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。


## weak_ptr

- weak_ptr 是用来解决 shared_ptr 相互引用时的死锁问题, 如果说两个 shared_ptr 相互引用, 那么这两个指针的引用计数永远不可能下降为 0,资源永远不会释放。
- 它是对对象的一种弱引用，不会增加对象的引用计数，和 shared_ptr 之间可以相互转化，shared_ptr 可以直接赋值给它，它可以通过调用 lock 函数来获得 shared_ptr。