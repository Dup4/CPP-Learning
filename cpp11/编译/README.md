# 编译


## 预处理 Preprocessing

编译命令：

```bash
g++ -E main.cpp -o main.i
```

- 删除#define，展开所有宏定义。例#define portnumber 3333。
- 处理条件预编译`#if`, `#ifdef`, `#if`, `#elif`, `#endif`。
- 处理`#include`预编译指令，将包含的`.h`文件插入对应位置。这可是递归进行的，文件内可能包含其他`.h`文件。
- 删除所有注释。`/**/`，`//`。
- 添加行号和文件标识符。用于显示调试信息：错误或警告的位置。
- 保留`#pragma`编译器指令。
	1. 设定编译器状态。
	2. 指示编译器完成一些特定的动作。

## 编译 Compilation

编译命令：

```bash
g++ -s main.cpp -o main.s
```

主要作用：

1. 扫描（词法分析）。
2. 语法分析。
3. 语义分析。
4. 源代码优化（中间语言生成）。
5. 代码生成，目标代码优化。

- 将源代码程序输入扫描器，将源代码的字符序列分割成一系列记号。例`array[index] =  (index + 4) * (2 + 6)`。
- 基于词法分析得到的一系列记号，生成语法树。
- 由语义分析器完成，指示判断是否合法，并不判断对错。又分静态语义：隐含浮点型到整形的转换，会报`warning`。
- 动态语义：在运行时才能确定：例1除以3。
- 中间代码（语言）使得编译器分为前端和后端，前端产生与机器（或环境）无关的中间代码，编译器的后端将中间代码转换为目标机器代码，目的：一个前端对多个后端，适应不同平台。
- 编译器后端主要包括：代码生成器: 依赖于目标机器，依赖目标机器的不同字长，寄存器，数据类型等
- 目标代码优化器: 选择合适的寻址方式，左移右移代替乘除，删除多余指令。

## 汇编 assembly

编译命令：

```bash
g++ -c main.cpp -o hello.o
```

主要作用：汇编器是将汇编代码转变成可以执行的指令，生成目标文件。

在这一阶段，编译器通过两个连续的步骤，将预处理器产生的代码编译成目标文件(object file)。

- 在`C++`中，如果一个对象只声明，不进行定义，编译器仍然可以从源代码产生目标文件——因为这个对象也可以指向某些当前代码中还未定义的标识符。
- 其次，汇编器将上一步生成的汇编代码逐行转换成字节码（也就是机器码）。
- 实际上，如果你希望把代码的不同部分分开编译的话，编译过程在这一步之后就可以停止了。
- 这一步生成的目标文件可以被放在被称为静态库的包中，以备后续使用——也就是说，如果你只修改了一个文件，你并不需要重新编译整个项目的源代码。

## 链接 Linking

编译命令：

```bash
g++ main.o -o main
```

- 主要作用：通过编译器的 $5$ 个步骤后，我们获得目标代码，但是里面的各个地址还没有确定，空间还没有分配。
- 链接过程主要包括：地址和空间的分配，符号决议和重定位。
- 地址和空间：略
- 符号决议：也可以说地址绑定，分动态链接和静态链接，
- 重定位：假设此时又两个文件：A，B。A需要B中的某个函数mov的地址，未链接前将地址置为0，当A与B链接后修改目标地址，完成重定位。
- 链接器利用编译器产生的目标文件，生成最终结果。
- 在这一阶段，编译器将把上一阶段中编译器产生的各种目标文件链接起来，将未定义标识符的引用全部替换成它们对应的正确地址。
- 没有把目标文件链接起来，就无法生成能够正常工作的程序——就像一页没有页码的目录一样，没什么用处。
- 完成链接工作之后，链接器根据编译目的不同，把链接的结果生成为一个动态链接库，或是一个可执行文件。
- 链接的过程也会抛出各种异常，通常是重复定义或者缺失定义等错误。
	- 不只是没进行定义的情况，如果你忘记将对某个库或是目标文件的引用导入进来，让链接器能找到定义的话，也会发生这类错误。
	- 重复定义则刚好相反，当有两个库或目标文件中含有对同一个标识符的定义时，就可能出现重复定义错误。